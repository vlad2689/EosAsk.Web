/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.15.0 (NJsonSchema v9.13.22.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class HomeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
    }

    index(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/home";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIndex(_response);
        });
    }

    protected processIndex(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    index2(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIndex2(_response);
        });
    }

    protected processIndex2(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    about(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/home/about";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAbout(_response);
        });
    }

    protected processAbout(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    about2(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/about";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAbout2(_response);
        });
    }

    protected processAbout2(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    contact(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/home/contact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContact(_response);
        });
    }

    protected processContact(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    contact2(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/contact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContact2(_response);
        });
    }

    protected processContact2(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    privacy(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/home/privacy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrivacy(_response);
        });
    }

    protected processPrivacy(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    privacy2(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/privacy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrivacy2(_response);
        });
    }

    protected processPrivacy2(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    error(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/home/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processError(_response);
        });
    }

    protected processError(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    error2(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processError2(_response);
        });
    }

    protected processError2(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export class AnswersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
    }

    getAnswers(): Promise<Answer[] | null> {
        let url_ = this.baseUrl + "/api/answers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAnswers(_response);
        });
    }

    protected processGetAnswers(response: Response): Promise<Answer[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Answer.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Answer[] | null>(<any>null);
    }

    postAnswer(postAnswerDto: PostAnswerDTO): Promise<Answer | null> {
        let url_ = this.baseUrl + "/api/answers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(postAnswerDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostAnswer(_response);
        });
    }

    protected processPostAnswer(response: Response): Promise<Answer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Answer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Answer | null>(<any>null);
    }

    getAnswer(id: number): Promise<Answer | null> {
        let url_ = this.baseUrl + "/api/answers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAnswer(_response);
        });
    }

    protected processGetAnswer(response: Response): Promise<Answer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Answer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Answer | null>(<any>null);
    }

    putAnswer(id: number, answerId: number | undefined, text: string | null | undefined, question_QuestionId: number | undefined, question_Title: string | null | undefined, question_Text: string | null | undefined, question_UpVotes: number | undefined, question_Owner_Id: string | null | undefined, question_Owner_UserName: string | null | undefined, question_Owner_NormalizedUserName: string | null | undefined, question_Owner_Email: string | null | undefined, question_Owner_NormalizedEmail: string | null | undefined, question_Owner_EmailConfirmed: boolean | undefined, question_Owner_PasswordHash: string | null | undefined, question_Owner_SecurityStamp: string | null | undefined, question_Owner_ConcurrencyStamp: string | null | undefined, question_Owner_PhoneNumber: string | null | undefined, question_Owner_PhoneNumberConfirmed: boolean | undefined, question_Owner_TwoFactorEnabled: boolean | undefined, question_Owner_LockoutEnd: Date | null | undefined, question_Owner_LockoutEnabled: boolean | undefined, question_Owner_AccessFailedCount: number | undefined, question_Answers: Answer[] | null | undefined, owner_Id: string | null | undefined, owner_UserName: string | null | undefined, owner_NormalizedUserName: string | null | undefined, owner_Email: string | null | undefined, owner_NormalizedEmail: string | null | undefined, owner_EmailConfirmed: boolean | undefined, owner_PasswordHash: string | null | undefined, owner_SecurityStamp: string | null | undefined, owner_ConcurrencyStamp: string | null | undefined, owner_PhoneNumber: string | null | undefined, owner_PhoneNumberConfirmed: boolean | undefined, owner_TwoFactorEnabled: boolean | undefined, owner_LockoutEnd: Date | null | undefined, owner_LockoutEnabled: boolean | undefined, owner_AccessFailedCount: number | undefined, upvoteCount: number | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (answerId === null)
            throw new Error("The parameter 'answerId' cannot be null.");
        else if (answerId !== undefined)
            url_ += "AnswerId=" + encodeURIComponent("" + answerId) + "&"; 
        if (text !== undefined)
            url_ += "Text=" + encodeURIComponent("" + text) + "&"; 
        if (question_QuestionId === null)
            throw new Error("The parameter 'question_QuestionId' cannot be null.");
        else if (question_QuestionId !== undefined)
            url_ += "Question.QuestionId=" + encodeURIComponent("" + question_QuestionId) + "&"; 
        if (question_Title !== undefined)
            url_ += "Question.Title=" + encodeURIComponent("" + question_Title) + "&"; 
        if (question_Text !== undefined)
            url_ += "Question.Text=" + encodeURIComponent("" + question_Text) + "&"; 
        if (question_UpVotes === null)
            throw new Error("The parameter 'question_UpVotes' cannot be null.");
        else if (question_UpVotes !== undefined)
            url_ += "Question.UpVotes=" + encodeURIComponent("" + question_UpVotes) + "&"; 
        if (question_Owner_Id !== undefined)
            url_ += "Question.Owner.Id=" + encodeURIComponent("" + question_Owner_Id) + "&"; 
        if (question_Owner_UserName !== undefined)
            url_ += "Question.Owner.UserName=" + encodeURIComponent("" + question_Owner_UserName) + "&"; 
        if (question_Owner_NormalizedUserName !== undefined)
            url_ += "Question.Owner.NormalizedUserName=" + encodeURIComponent("" + question_Owner_NormalizedUserName) + "&"; 
        if (question_Owner_Email !== undefined)
            url_ += "Question.Owner.Email=" + encodeURIComponent("" + question_Owner_Email) + "&"; 
        if (question_Owner_NormalizedEmail !== undefined)
            url_ += "Question.Owner.NormalizedEmail=" + encodeURIComponent("" + question_Owner_NormalizedEmail) + "&"; 
        if (question_Owner_EmailConfirmed === null)
            throw new Error("The parameter 'question_Owner_EmailConfirmed' cannot be null.");
        else if (question_Owner_EmailConfirmed !== undefined)
            url_ += "Question.Owner.EmailConfirmed=" + encodeURIComponent("" + question_Owner_EmailConfirmed) + "&"; 
        if (question_Owner_PasswordHash !== undefined)
            url_ += "Question.Owner.PasswordHash=" + encodeURIComponent("" + question_Owner_PasswordHash) + "&"; 
        if (question_Owner_SecurityStamp !== undefined)
            url_ += "Question.Owner.SecurityStamp=" + encodeURIComponent("" + question_Owner_SecurityStamp) + "&"; 
        if (question_Owner_ConcurrencyStamp !== undefined)
            url_ += "Question.Owner.ConcurrencyStamp=" + encodeURIComponent("" + question_Owner_ConcurrencyStamp) + "&"; 
        if (question_Owner_PhoneNumber !== undefined)
            url_ += "Question.Owner.PhoneNumber=" + encodeURIComponent("" + question_Owner_PhoneNumber) + "&"; 
        if (question_Owner_PhoneNumberConfirmed === null)
            throw new Error("The parameter 'question_Owner_PhoneNumberConfirmed' cannot be null.");
        else if (question_Owner_PhoneNumberConfirmed !== undefined)
            url_ += "Question.Owner.PhoneNumberConfirmed=" + encodeURIComponent("" + question_Owner_PhoneNumberConfirmed) + "&"; 
        if (question_Owner_TwoFactorEnabled === null)
            throw new Error("The parameter 'question_Owner_TwoFactorEnabled' cannot be null.");
        else if (question_Owner_TwoFactorEnabled !== undefined)
            url_ += "Question.Owner.TwoFactorEnabled=" + encodeURIComponent("" + question_Owner_TwoFactorEnabled) + "&"; 
        if (question_Owner_LockoutEnd !== undefined)
            url_ += "Question.Owner.LockoutEnd=" + encodeURIComponent(question_Owner_LockoutEnd ? "" + question_Owner_LockoutEnd.toJSON() : "") + "&"; 
        if (question_Owner_LockoutEnabled === null)
            throw new Error("The parameter 'question_Owner_LockoutEnabled' cannot be null.");
        else if (question_Owner_LockoutEnabled !== undefined)
            url_ += "Question.Owner.LockoutEnabled=" + encodeURIComponent("" + question_Owner_LockoutEnabled) + "&"; 
        if (question_Owner_AccessFailedCount === null)
            throw new Error("The parameter 'question_Owner_AccessFailedCount' cannot be null.");
        else if (question_Owner_AccessFailedCount !== undefined)
            url_ += "Question.Owner.AccessFailedCount=" + encodeURIComponent("" + question_Owner_AccessFailedCount) + "&"; 
        if (question_Answers !== undefined)
            question_Answers && question_Answers.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Question.Answers[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (owner_Id !== undefined)
            url_ += "Owner.Id=" + encodeURIComponent("" + owner_Id) + "&"; 
        if (owner_UserName !== undefined)
            url_ += "Owner.UserName=" + encodeURIComponent("" + owner_UserName) + "&"; 
        if (owner_NormalizedUserName !== undefined)
            url_ += "Owner.NormalizedUserName=" + encodeURIComponent("" + owner_NormalizedUserName) + "&"; 
        if (owner_Email !== undefined)
            url_ += "Owner.Email=" + encodeURIComponent("" + owner_Email) + "&"; 
        if (owner_NormalizedEmail !== undefined)
            url_ += "Owner.NormalizedEmail=" + encodeURIComponent("" + owner_NormalizedEmail) + "&"; 
        if (owner_EmailConfirmed === null)
            throw new Error("The parameter 'owner_EmailConfirmed' cannot be null.");
        else if (owner_EmailConfirmed !== undefined)
            url_ += "Owner.EmailConfirmed=" + encodeURIComponent("" + owner_EmailConfirmed) + "&"; 
        if (owner_PasswordHash !== undefined)
            url_ += "Owner.PasswordHash=" + encodeURIComponent("" + owner_PasswordHash) + "&"; 
        if (owner_SecurityStamp !== undefined)
            url_ += "Owner.SecurityStamp=" + encodeURIComponent("" + owner_SecurityStamp) + "&"; 
        if (owner_ConcurrencyStamp !== undefined)
            url_ += "Owner.ConcurrencyStamp=" + encodeURIComponent("" + owner_ConcurrencyStamp) + "&"; 
        if (owner_PhoneNumber !== undefined)
            url_ += "Owner.PhoneNumber=" + encodeURIComponent("" + owner_PhoneNumber) + "&"; 
        if (owner_PhoneNumberConfirmed === null)
            throw new Error("The parameter 'owner_PhoneNumberConfirmed' cannot be null.");
        else if (owner_PhoneNumberConfirmed !== undefined)
            url_ += "Owner.PhoneNumberConfirmed=" + encodeURIComponent("" + owner_PhoneNumberConfirmed) + "&"; 
        if (owner_TwoFactorEnabled === null)
            throw new Error("The parameter 'owner_TwoFactorEnabled' cannot be null.");
        else if (owner_TwoFactorEnabled !== undefined)
            url_ += "Owner.TwoFactorEnabled=" + encodeURIComponent("" + owner_TwoFactorEnabled) + "&"; 
        if (owner_LockoutEnd !== undefined)
            url_ += "Owner.LockoutEnd=" + encodeURIComponent(owner_LockoutEnd ? "" + owner_LockoutEnd.toJSON() : "") + "&"; 
        if (owner_LockoutEnabled === null)
            throw new Error("The parameter 'owner_LockoutEnabled' cannot be null.");
        else if (owner_LockoutEnabled !== undefined)
            url_ += "Owner.LockoutEnabled=" + encodeURIComponent("" + owner_LockoutEnabled) + "&"; 
        if (owner_AccessFailedCount === null)
            throw new Error("The parameter 'owner_AccessFailedCount' cannot be null.");
        else if (owner_AccessFailedCount !== undefined)
            url_ += "Owner.AccessFailedCount=" + encodeURIComponent("" + owner_AccessFailedCount) + "&"; 
        if (upvoteCount === null)
            throw new Error("The parameter 'upvoteCount' cannot be null.");
        else if (upvoteCount !== undefined)
            url_ += "UpvoteCount=" + encodeURIComponent("" + upvoteCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutAnswer(_response);
        });
    }

    protected processPutAnswer(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    deleteAnswer(id: number): Promise<Answer | null> {
        let url_ = this.baseUrl + "/api/answers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAnswer(_response);
        });
    }

    protected processDeleteAnswer(response: Response): Promise<Answer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Answer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Answer | null>(<any>null);
    }
}

export class BountiesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
    }

    getBounties(): Promise<Bounty[] | null> {
        let url_ = this.baseUrl + "/api/bounties";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBounties(_response);
        });
    }

    protected processGetBounties(response: Response): Promise<Bounty[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Bounty.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bounty[] | null>(<any>null);
    }

    postBounty(postBountyDto: PostBountyDTO): Promise<Bounty | null> {
        let url_ = this.baseUrl + "/api/bounties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(postBountyDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostBounty(_response);
        });
    }

    protected processPostBounty(response: Response): Promise<Bounty | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Bounty.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bounty | null>(<any>null);
    }

    getBounty(id: number): Promise<Bounty | null> {
        let url_ = this.baseUrl + "/api/bounties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBounty(_response);
        });
    }

    protected processGetBounty(response: Response): Promise<Bounty | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Bounty.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bounty | null>(<any>null);
    }

    putBounty(id: number, bountyId: number | undefined, amount: number | undefined, amountSym: string | null | undefined, question_QuestionId: number | undefined, question_Title: string | null | undefined, question_Text: string | null | undefined, question_UpVotes: number | undefined, question_Owner_Id: string | null | undefined, question_Owner_UserName: string | null | undefined, question_Owner_NormalizedUserName: string | null | undefined, question_Owner_Email: string | null | undefined, question_Owner_NormalizedEmail: string | null | undefined, question_Owner_EmailConfirmed: boolean | undefined, question_Owner_PasswordHash: string | null | undefined, question_Owner_SecurityStamp: string | null | undefined, question_Owner_ConcurrencyStamp: string | null | undefined, question_Owner_PhoneNumber: string | null | undefined, question_Owner_PhoneNumberConfirmed: boolean | undefined, question_Owner_TwoFactorEnabled: boolean | undefined, question_Owner_LockoutEnd: Date | null | undefined, question_Owner_LockoutEnabled: boolean | undefined, question_Owner_AccessFailedCount: number | undefined, question_Answers: Answer[] | null | undefined, owner_Id: string | null | undefined, owner_UserName: string | null | undefined, owner_NormalizedUserName: string | null | undefined, owner_Email: string | null | undefined, owner_NormalizedEmail: string | null | undefined, owner_EmailConfirmed: boolean | undefined, owner_PasswordHash: string | null | undefined, owner_SecurityStamp: string | null | undefined, owner_ConcurrencyStamp: string | null | undefined, owner_PhoneNumber: string | null | undefined, owner_PhoneNumberConfirmed: boolean | undefined, owner_TwoFactorEnabled: boolean | undefined, owner_LockoutEnd: Date | null | undefined, owner_LockoutEnabled: boolean | undefined, owner_AccessFailedCount: number | undefined, awarded_Id: string | null | undefined, awarded_UserName: string | null | undefined, awarded_NormalizedUserName: string | null | undefined, awarded_Email: string | null | undefined, awarded_NormalizedEmail: string | null | undefined, awarded_EmailConfirmed: boolean | undefined, awarded_PasswordHash: string | null | undefined, awarded_SecurityStamp: string | null | undefined, awarded_ConcurrencyStamp: string | null | undefined, awarded_PhoneNumber: string | null | undefined, awarded_PhoneNumberConfirmed: boolean | undefined, awarded_TwoFactorEnabled: boolean | undefined, awarded_LockoutEnd: Date | null | undefined, awarded_LockoutEnabled: boolean | undefined, awarded_AccessFailedCount: number | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/bounties/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (bountyId === null)
            throw new Error("The parameter 'bountyId' cannot be null.");
        else if (bountyId !== undefined)
            url_ += "BountyId=" + encodeURIComponent("" + bountyId) + "&"; 
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "Amount=" + encodeURIComponent("" + amount) + "&"; 
        if (amountSym !== undefined)
            url_ += "AmountSym=" + encodeURIComponent("" + amountSym) + "&"; 
        if (question_QuestionId === null)
            throw new Error("The parameter 'question_QuestionId' cannot be null.");
        else if (question_QuestionId !== undefined)
            url_ += "Question.QuestionId=" + encodeURIComponent("" + question_QuestionId) + "&"; 
        if (question_Title !== undefined)
            url_ += "Question.Title=" + encodeURIComponent("" + question_Title) + "&"; 
        if (question_Text !== undefined)
            url_ += "Question.Text=" + encodeURIComponent("" + question_Text) + "&"; 
        if (question_UpVotes === null)
            throw new Error("The parameter 'question_UpVotes' cannot be null.");
        else if (question_UpVotes !== undefined)
            url_ += "Question.UpVotes=" + encodeURIComponent("" + question_UpVotes) + "&"; 
        if (question_Owner_Id !== undefined)
            url_ += "Question.Owner.Id=" + encodeURIComponent("" + question_Owner_Id) + "&"; 
        if (question_Owner_UserName !== undefined)
            url_ += "Question.Owner.UserName=" + encodeURIComponent("" + question_Owner_UserName) + "&"; 
        if (question_Owner_NormalizedUserName !== undefined)
            url_ += "Question.Owner.NormalizedUserName=" + encodeURIComponent("" + question_Owner_NormalizedUserName) + "&"; 
        if (question_Owner_Email !== undefined)
            url_ += "Question.Owner.Email=" + encodeURIComponent("" + question_Owner_Email) + "&"; 
        if (question_Owner_NormalizedEmail !== undefined)
            url_ += "Question.Owner.NormalizedEmail=" + encodeURIComponent("" + question_Owner_NormalizedEmail) + "&"; 
        if (question_Owner_EmailConfirmed === null)
            throw new Error("The parameter 'question_Owner_EmailConfirmed' cannot be null.");
        else if (question_Owner_EmailConfirmed !== undefined)
            url_ += "Question.Owner.EmailConfirmed=" + encodeURIComponent("" + question_Owner_EmailConfirmed) + "&"; 
        if (question_Owner_PasswordHash !== undefined)
            url_ += "Question.Owner.PasswordHash=" + encodeURIComponent("" + question_Owner_PasswordHash) + "&"; 
        if (question_Owner_SecurityStamp !== undefined)
            url_ += "Question.Owner.SecurityStamp=" + encodeURIComponent("" + question_Owner_SecurityStamp) + "&"; 
        if (question_Owner_ConcurrencyStamp !== undefined)
            url_ += "Question.Owner.ConcurrencyStamp=" + encodeURIComponent("" + question_Owner_ConcurrencyStamp) + "&"; 
        if (question_Owner_PhoneNumber !== undefined)
            url_ += "Question.Owner.PhoneNumber=" + encodeURIComponent("" + question_Owner_PhoneNumber) + "&"; 
        if (question_Owner_PhoneNumberConfirmed === null)
            throw new Error("The parameter 'question_Owner_PhoneNumberConfirmed' cannot be null.");
        else if (question_Owner_PhoneNumberConfirmed !== undefined)
            url_ += "Question.Owner.PhoneNumberConfirmed=" + encodeURIComponent("" + question_Owner_PhoneNumberConfirmed) + "&"; 
        if (question_Owner_TwoFactorEnabled === null)
            throw new Error("The parameter 'question_Owner_TwoFactorEnabled' cannot be null.");
        else if (question_Owner_TwoFactorEnabled !== undefined)
            url_ += "Question.Owner.TwoFactorEnabled=" + encodeURIComponent("" + question_Owner_TwoFactorEnabled) + "&"; 
        if (question_Owner_LockoutEnd !== undefined)
            url_ += "Question.Owner.LockoutEnd=" + encodeURIComponent(question_Owner_LockoutEnd ? "" + question_Owner_LockoutEnd.toJSON() : "") + "&"; 
        if (question_Owner_LockoutEnabled === null)
            throw new Error("The parameter 'question_Owner_LockoutEnabled' cannot be null.");
        else if (question_Owner_LockoutEnabled !== undefined)
            url_ += "Question.Owner.LockoutEnabled=" + encodeURIComponent("" + question_Owner_LockoutEnabled) + "&"; 
        if (question_Owner_AccessFailedCount === null)
            throw new Error("The parameter 'question_Owner_AccessFailedCount' cannot be null.");
        else if (question_Owner_AccessFailedCount !== undefined)
            url_ += "Question.Owner.AccessFailedCount=" + encodeURIComponent("" + question_Owner_AccessFailedCount) + "&"; 
        if (question_Answers !== undefined)
            question_Answers && question_Answers.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Question.Answers[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (owner_Id !== undefined)
            url_ += "Owner.Id=" + encodeURIComponent("" + owner_Id) + "&"; 
        if (owner_UserName !== undefined)
            url_ += "Owner.UserName=" + encodeURIComponent("" + owner_UserName) + "&"; 
        if (owner_NormalizedUserName !== undefined)
            url_ += "Owner.NormalizedUserName=" + encodeURIComponent("" + owner_NormalizedUserName) + "&"; 
        if (owner_Email !== undefined)
            url_ += "Owner.Email=" + encodeURIComponent("" + owner_Email) + "&"; 
        if (owner_NormalizedEmail !== undefined)
            url_ += "Owner.NormalizedEmail=" + encodeURIComponent("" + owner_NormalizedEmail) + "&"; 
        if (owner_EmailConfirmed === null)
            throw new Error("The parameter 'owner_EmailConfirmed' cannot be null.");
        else if (owner_EmailConfirmed !== undefined)
            url_ += "Owner.EmailConfirmed=" + encodeURIComponent("" + owner_EmailConfirmed) + "&"; 
        if (owner_PasswordHash !== undefined)
            url_ += "Owner.PasswordHash=" + encodeURIComponent("" + owner_PasswordHash) + "&"; 
        if (owner_SecurityStamp !== undefined)
            url_ += "Owner.SecurityStamp=" + encodeURIComponent("" + owner_SecurityStamp) + "&"; 
        if (owner_ConcurrencyStamp !== undefined)
            url_ += "Owner.ConcurrencyStamp=" + encodeURIComponent("" + owner_ConcurrencyStamp) + "&"; 
        if (owner_PhoneNumber !== undefined)
            url_ += "Owner.PhoneNumber=" + encodeURIComponent("" + owner_PhoneNumber) + "&"; 
        if (owner_PhoneNumberConfirmed === null)
            throw new Error("The parameter 'owner_PhoneNumberConfirmed' cannot be null.");
        else if (owner_PhoneNumberConfirmed !== undefined)
            url_ += "Owner.PhoneNumberConfirmed=" + encodeURIComponent("" + owner_PhoneNumberConfirmed) + "&"; 
        if (owner_TwoFactorEnabled === null)
            throw new Error("The parameter 'owner_TwoFactorEnabled' cannot be null.");
        else if (owner_TwoFactorEnabled !== undefined)
            url_ += "Owner.TwoFactorEnabled=" + encodeURIComponent("" + owner_TwoFactorEnabled) + "&"; 
        if (owner_LockoutEnd !== undefined)
            url_ += "Owner.LockoutEnd=" + encodeURIComponent(owner_LockoutEnd ? "" + owner_LockoutEnd.toJSON() : "") + "&"; 
        if (owner_LockoutEnabled === null)
            throw new Error("The parameter 'owner_LockoutEnabled' cannot be null.");
        else if (owner_LockoutEnabled !== undefined)
            url_ += "Owner.LockoutEnabled=" + encodeURIComponent("" + owner_LockoutEnabled) + "&"; 
        if (owner_AccessFailedCount === null)
            throw new Error("The parameter 'owner_AccessFailedCount' cannot be null.");
        else if (owner_AccessFailedCount !== undefined)
            url_ += "Owner.AccessFailedCount=" + encodeURIComponent("" + owner_AccessFailedCount) + "&"; 
        if (awarded_Id !== undefined)
            url_ += "Awarded.Id=" + encodeURIComponent("" + awarded_Id) + "&"; 
        if (awarded_UserName !== undefined)
            url_ += "Awarded.UserName=" + encodeURIComponent("" + awarded_UserName) + "&"; 
        if (awarded_NormalizedUserName !== undefined)
            url_ += "Awarded.NormalizedUserName=" + encodeURIComponent("" + awarded_NormalizedUserName) + "&"; 
        if (awarded_Email !== undefined)
            url_ += "Awarded.Email=" + encodeURIComponent("" + awarded_Email) + "&"; 
        if (awarded_NormalizedEmail !== undefined)
            url_ += "Awarded.NormalizedEmail=" + encodeURIComponent("" + awarded_NormalizedEmail) + "&"; 
        if (awarded_EmailConfirmed === null)
            throw new Error("The parameter 'awarded_EmailConfirmed' cannot be null.");
        else if (awarded_EmailConfirmed !== undefined)
            url_ += "Awarded.EmailConfirmed=" + encodeURIComponent("" + awarded_EmailConfirmed) + "&"; 
        if (awarded_PasswordHash !== undefined)
            url_ += "Awarded.PasswordHash=" + encodeURIComponent("" + awarded_PasswordHash) + "&"; 
        if (awarded_SecurityStamp !== undefined)
            url_ += "Awarded.SecurityStamp=" + encodeURIComponent("" + awarded_SecurityStamp) + "&"; 
        if (awarded_ConcurrencyStamp !== undefined)
            url_ += "Awarded.ConcurrencyStamp=" + encodeURIComponent("" + awarded_ConcurrencyStamp) + "&"; 
        if (awarded_PhoneNumber !== undefined)
            url_ += "Awarded.PhoneNumber=" + encodeURIComponent("" + awarded_PhoneNumber) + "&"; 
        if (awarded_PhoneNumberConfirmed === null)
            throw new Error("The parameter 'awarded_PhoneNumberConfirmed' cannot be null.");
        else if (awarded_PhoneNumberConfirmed !== undefined)
            url_ += "Awarded.PhoneNumberConfirmed=" + encodeURIComponent("" + awarded_PhoneNumberConfirmed) + "&"; 
        if (awarded_TwoFactorEnabled === null)
            throw new Error("The parameter 'awarded_TwoFactorEnabled' cannot be null.");
        else if (awarded_TwoFactorEnabled !== undefined)
            url_ += "Awarded.TwoFactorEnabled=" + encodeURIComponent("" + awarded_TwoFactorEnabled) + "&"; 
        if (awarded_LockoutEnd !== undefined)
            url_ += "Awarded.LockoutEnd=" + encodeURIComponent(awarded_LockoutEnd ? "" + awarded_LockoutEnd.toJSON() : "") + "&"; 
        if (awarded_LockoutEnabled === null)
            throw new Error("The parameter 'awarded_LockoutEnabled' cannot be null.");
        else if (awarded_LockoutEnabled !== undefined)
            url_ += "Awarded.LockoutEnabled=" + encodeURIComponent("" + awarded_LockoutEnabled) + "&"; 
        if (awarded_AccessFailedCount === null)
            throw new Error("The parameter 'awarded_AccessFailedCount' cannot be null.");
        else if (awarded_AccessFailedCount !== undefined)
            url_ += "Awarded.AccessFailedCount=" + encodeURIComponent("" + awarded_AccessFailedCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutBounty(_response);
        });
    }

    protected processPutBounty(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    deleteBounty(id: number): Promise<Bounty | null> {
        let url_ = this.baseUrl + "/api/bounties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteBounty(_response);
        });
    }

    protected processDeleteBounty(response: Response): Promise<Bounty | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Bounty.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bounty | null>(<any>null);
    }
}

export class CheckLoginClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
    }

    getLoginStatus(): Promise<UserDTO | null> {
        let url_ = this.baseUrl + "/api/checklogin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLoginStatus(_response);
        });
    }

    protected processGetLoginStatus(response: Response): Promise<UserDTO | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDTO.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDTO | null>(<any>null);
    }
}

export class QuestionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
    }

    getQuestions(): Promise<QuestionDTO[] | null> {
        let url_ = this.baseUrl + "/api/questions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuestions(_response);
        });
    }

    protected processGetQuestions(response: Response): Promise<QuestionDTO[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QuestionDTO.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QuestionDTO[] | null>(<any>null);
    }

    postQuestion(postQuestionDto: PostQuestionDTO): Promise<Question | null> {
        let url_ = this.baseUrl + "/api/questions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(postQuestionDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostQuestion(_response);
        });
    }

    protected processPostQuestion(response: Response): Promise<Question | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Question.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Question | null>(<any>null);
    }

    getQuestion(id: number): Promise<QuestionDTO | null> {
        let url_ = this.baseUrl + "/api/questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuestion(_response);
        });
    }

    protected processGetQuestion(response: Response): Promise<QuestionDTO | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionDTO.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QuestionDTO | null>(<any>null);
    }

    putQuestion(id: number, questionId: number | undefined, title: string | null | undefined, text: string | null | undefined, upVotes: number | undefined, owner_Id: string | null | undefined, owner_UserName: string | null | undefined, owner_NormalizedUserName: string | null | undefined, owner_Email: string | null | undefined, owner_NormalizedEmail: string | null | undefined, owner_EmailConfirmed: boolean | undefined, owner_PasswordHash: string | null | undefined, owner_SecurityStamp: string | null | undefined, owner_ConcurrencyStamp: string | null | undefined, owner_PhoneNumber: string | null | undefined, owner_PhoneNumberConfirmed: boolean | undefined, owner_TwoFactorEnabled: boolean | undefined, owner_LockoutEnd: Date | null | undefined, owner_LockoutEnabled: boolean | undefined, owner_AccessFailedCount: number | undefined, answers: Answer[] | null | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (questionId === null)
            throw new Error("The parameter 'questionId' cannot be null.");
        else if (questionId !== undefined)
            url_ += "QuestionId=" + encodeURIComponent("" + questionId) + "&"; 
        if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&"; 
        if (text !== undefined)
            url_ += "Text=" + encodeURIComponent("" + text) + "&"; 
        if (upVotes === null)
            throw new Error("The parameter 'upVotes' cannot be null.");
        else if (upVotes !== undefined)
            url_ += "UpVotes=" + encodeURIComponent("" + upVotes) + "&"; 
        if (owner_Id !== undefined)
            url_ += "Owner.Id=" + encodeURIComponent("" + owner_Id) + "&"; 
        if (owner_UserName !== undefined)
            url_ += "Owner.UserName=" + encodeURIComponent("" + owner_UserName) + "&"; 
        if (owner_NormalizedUserName !== undefined)
            url_ += "Owner.NormalizedUserName=" + encodeURIComponent("" + owner_NormalizedUserName) + "&"; 
        if (owner_Email !== undefined)
            url_ += "Owner.Email=" + encodeURIComponent("" + owner_Email) + "&"; 
        if (owner_NormalizedEmail !== undefined)
            url_ += "Owner.NormalizedEmail=" + encodeURIComponent("" + owner_NormalizedEmail) + "&"; 
        if (owner_EmailConfirmed === null)
            throw new Error("The parameter 'owner_EmailConfirmed' cannot be null.");
        else if (owner_EmailConfirmed !== undefined)
            url_ += "Owner.EmailConfirmed=" + encodeURIComponent("" + owner_EmailConfirmed) + "&"; 
        if (owner_PasswordHash !== undefined)
            url_ += "Owner.PasswordHash=" + encodeURIComponent("" + owner_PasswordHash) + "&"; 
        if (owner_SecurityStamp !== undefined)
            url_ += "Owner.SecurityStamp=" + encodeURIComponent("" + owner_SecurityStamp) + "&"; 
        if (owner_ConcurrencyStamp !== undefined)
            url_ += "Owner.ConcurrencyStamp=" + encodeURIComponent("" + owner_ConcurrencyStamp) + "&"; 
        if (owner_PhoneNumber !== undefined)
            url_ += "Owner.PhoneNumber=" + encodeURIComponent("" + owner_PhoneNumber) + "&"; 
        if (owner_PhoneNumberConfirmed === null)
            throw new Error("The parameter 'owner_PhoneNumberConfirmed' cannot be null.");
        else if (owner_PhoneNumberConfirmed !== undefined)
            url_ += "Owner.PhoneNumberConfirmed=" + encodeURIComponent("" + owner_PhoneNumberConfirmed) + "&"; 
        if (owner_TwoFactorEnabled === null)
            throw new Error("The parameter 'owner_TwoFactorEnabled' cannot be null.");
        else if (owner_TwoFactorEnabled !== undefined)
            url_ += "Owner.TwoFactorEnabled=" + encodeURIComponent("" + owner_TwoFactorEnabled) + "&"; 
        if (owner_LockoutEnd !== undefined)
            url_ += "Owner.LockoutEnd=" + encodeURIComponent(owner_LockoutEnd ? "" + owner_LockoutEnd.toJSON() : "") + "&"; 
        if (owner_LockoutEnabled === null)
            throw new Error("The parameter 'owner_LockoutEnabled' cannot be null.");
        else if (owner_LockoutEnabled !== undefined)
            url_ += "Owner.LockoutEnabled=" + encodeURIComponent("" + owner_LockoutEnabled) + "&"; 
        if (owner_AccessFailedCount === null)
            throw new Error("The parameter 'owner_AccessFailedCount' cannot be null.");
        else if (owner_AccessFailedCount !== undefined)
            url_ += "Owner.AccessFailedCount=" + encodeURIComponent("" + owner_AccessFailedCount) + "&"; 
        if (answers !== undefined)
            answers && answers.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Answers[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutQuestion(_response);
        });
    }

    protected processPutQuestion(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    deleteQuestion(id: number): Promise<Question | null> {
        let url_ = this.baseUrl + "/api/questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteQuestion(_response);
        });
    }

    protected processDeleteQuestion(response: Response): Promise<Question | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Question.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Question | null>(<any>null);
    }
}

export class Answer implements IAnswer {
    answerId!: number;
    text!: string;
    question!: Question;
    owner!: IdentityUser;
    upvoteCount!: number;

    constructor(data?: IAnswer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.question = new Question();
            this.owner = new IdentityUser();
        }
    }

    init(data?: any) {
        if (data) {
            this.answerId = data["answerId"];
            this.text = data["text"];
            this.question = data["question"] ? Question.fromJS(data["question"]) : new Question();
            this.owner = data["owner"] ? IdentityUser.fromJS(data["owner"]) : new IdentityUser();
            this.upvoteCount = data["upvoteCount"];
        }
    }

    static fromJS(data: any): Answer {
        data = typeof data === 'object' ? data : {};
        let result = new Answer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answerId"] = this.answerId;
        data["text"] = this.text;
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["upvoteCount"] = this.upvoteCount;
        return data; 
    }
}

export interface IAnswer {
    answerId: number;
    text: string;
    question: Question;
    owner: IdentityUser;
    upvoteCount: number;
}

export class Question implements IQuestion {
    questionId!: number;
    title!: string;
    text!: string;
    upVotes!: number;
    owner!: IdentityUser;
    answers?: Answer[] | undefined;

    constructor(data?: IQuestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.owner = new IdentityUser();
        }
    }

    init(data?: any) {
        if (data) {
            this.questionId = data["questionId"];
            this.title = data["title"];
            this.text = data["text"];
            this.upVotes = data["upVotes"];
            this.owner = data["owner"] ? IdentityUser.fromJS(data["owner"]) : new IdentityUser();
            if (data["answers"] && data["answers"].constructor === Array) {
                this.answers = [] as any;
                for (let item of data["answers"])
                    this.answers!.push(Answer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Question {
        data = typeof data === 'object' ? data : {};
        let result = new Question();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["title"] = this.title;
        data["text"] = this.text;
        data["upVotes"] = this.upVotes;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        if (this.answers && this.answers.constructor === Array) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuestion {
    questionId: number;
    title: string;
    text: string;
    upVotes: number;
    owner: IdentityUser;
    answers?: Answer[] | undefined;
}

export class IdentityUserOfString implements IIdentityUserOfString {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed!: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed!: boolean;
    twoFactorEnabled!: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled!: boolean;
    accessFailedCount!: number;

    constructor(data?: IIdentityUserOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.normalizedUserName = data["normalizedUserName"];
            this.email = data["email"];
            this.normalizedEmail = data["normalizedEmail"];
            this.emailConfirmed = data["emailConfirmed"];
            this.passwordHash = data["passwordHash"];
            this.securityStamp = data["securityStamp"];
            this.concurrencyStamp = data["concurrencyStamp"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneNumberConfirmed = data["phoneNumberConfirmed"];
            this.twoFactorEnabled = data["twoFactorEnabled"];
            this.lockoutEnd = data["lockoutEnd"] ? new Date(data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = data["lockoutEnabled"];
            this.accessFailedCount = data["accessFailedCount"];
        }
    }

    static fromJS(data: any): IdentityUserOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data; 
    }
}

export interface IIdentityUserOfString {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled: boolean;
    accessFailedCount: number;
}

export class IdentityUser extends IdentityUserOfString implements IIdentityUser {

    constructor(data?: IIdentityUser) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): IdentityUser {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IIdentityUser extends IIdentityUserOfString {
}

export class PostAnswerDTO implements IPostAnswerDTO {
    text!: string;
    questionId!: number;

    constructor(data?: IPostAnswerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.text = data["text"];
            this.questionId = data["questionId"];
        }
    }

    static fromJS(data: any): PostAnswerDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PostAnswerDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["questionId"] = this.questionId;
        return data; 
    }
}

export interface IPostAnswerDTO {
    text: string;
    questionId: number;
}

export class Bounty implements IBounty {
    bountyId!: number;
    amount!: number;
    amountSym!: string;
    question!: Question;
    owner!: IdentityUser;
    awarded?: IdentityUser | undefined;

    constructor(data?: IBounty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.question = new Question();
            this.owner = new IdentityUser();
        }
    }

    init(data?: any) {
        if (data) {
            this.bountyId = data["bountyId"];
            this.amount = data["amount"];
            this.amountSym = data["amountSym"];
            this.question = data["question"] ? Question.fromJS(data["question"]) : new Question();
            this.owner = data["owner"] ? IdentityUser.fromJS(data["owner"]) : new IdentityUser();
            this.awarded = data["awarded"] ? IdentityUser.fromJS(data["awarded"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Bounty {
        data = typeof data === 'object' ? data : {};
        let result = new Bounty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bountyId"] = this.bountyId;
        data["amount"] = this.amount;
        data["amountSym"] = this.amountSym;
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["awarded"] = this.awarded ? this.awarded.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBounty {
    bountyId: number;
    amount: number;
    amountSym: string;
    question: Question;
    owner: IdentityUser;
    awarded?: IdentityUser | undefined;
}

export class PostBountyDTO implements IPostBountyDTO {
    questionId!: number;
    amount!: number;
    amountSym?: string | undefined;

    constructor(data?: IPostBountyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionId = data["questionId"];
            this.amount = data["amount"];
            this.amountSym = data["amountSym"];
        }
    }

    static fromJS(data: any): PostBountyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PostBountyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["amount"] = this.amount;
        data["amountSym"] = this.amountSym;
        return data; 
    }
}

export interface IPostBountyDTO {
    questionId: number;
    amount: number;
    amountSym?: string | undefined;
}

export class UserDTO implements IUserDTO {
    user?: IdentityUser | undefined;

    constructor(data?: IUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? IdentityUser.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserDTO {
    user?: IdentityUser | undefined;
}

export class QuestionDTO implements IQuestionDTO {
    questionId!: number;
    title!: string;
    text!: string;
    upVotes!: number;
    owner!: IdentityUser;
    bounty?: BountyDTO | undefined;
    answers?: AnswerDTO[] | undefined;

    constructor(data?: IQuestionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.owner = new IdentityUser();
        }
    }

    init(data?: any) {
        if (data) {
            this.questionId = data["questionId"];
            this.title = data["title"];
            this.text = data["text"];
            this.upVotes = data["upVotes"];
            this.owner = data["owner"] ? IdentityUser.fromJS(data["owner"]) : new IdentityUser();
            this.bounty = data["bounty"] ? BountyDTO.fromJS(data["bounty"]) : <any>undefined;
            if (data["answers"] && data["answers"].constructor === Array) {
                this.answers = [] as any;
                for (let item of data["answers"])
                    this.answers!.push(AnswerDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["title"] = this.title;
        data["text"] = this.text;
        data["upVotes"] = this.upVotes;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["bounty"] = this.bounty ? this.bounty.toJSON() : <any>undefined;
        if (this.answers && this.answers.constructor === Array) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuestionDTO {
    questionId: number;
    title: string;
    text: string;
    upVotes: number;
    owner: IdentityUser;
    bounty?: BountyDTO | undefined;
    answers?: AnswerDTO[] | undefined;
}

export class BountyDTO implements IBountyDTO {
    bountyId!: number;
    amount!: number;
    amountSym!: string;
    question!: Question;
    owner!: IdentityUser;
    awarded?: IdentityUser | undefined;

    constructor(data?: IBountyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.question = new Question();
            this.owner = new IdentityUser();
        }
    }

    init(data?: any) {
        if (data) {
            this.bountyId = data["bountyId"];
            this.amount = data["amount"];
            this.amountSym = data["amountSym"];
            this.question = data["question"] ? Question.fromJS(data["question"]) : new Question();
            this.owner = data["owner"] ? IdentityUser.fromJS(data["owner"]) : new IdentityUser();
            this.awarded = data["awarded"] ? IdentityUser.fromJS(data["awarded"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BountyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BountyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bountyId"] = this.bountyId;
        data["amount"] = this.amount;
        data["amountSym"] = this.amountSym;
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["awarded"] = this.awarded ? this.awarded.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBountyDTO {
    bountyId: number;
    amount: number;
    amountSym: string;
    question: Question;
    owner: IdentityUser;
    awarded?: IdentityUser | undefined;
}

export class AnswerDTO implements IAnswerDTO {
    answerId!: number;
    text!: string;
    question!: Question;
    owner!: IdentityUser;
    upvoteCount!: number;

    constructor(data?: IAnswerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.question = new Question();
            this.owner = new IdentityUser();
        }
    }

    init(data?: any) {
        if (data) {
            this.answerId = data["answerId"];
            this.text = data["text"];
            this.question = data["question"] ? Question.fromJS(data["question"]) : new Question();
            this.owner = data["owner"] ? IdentityUser.fromJS(data["owner"]) : new IdentityUser();
            this.upvoteCount = data["upvoteCount"];
        }
    }

    static fromJS(data: any): AnswerDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answerId"] = this.answerId;
        data["text"] = this.text;
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["upvoteCount"] = this.upvoteCount;
        return data; 
    }
}

export interface IAnswerDTO {
    answerId: number;
    text: string;
    question: Question;
    owner: IdentityUser;
    upvoteCount: number;
}

export class PostQuestionDTO implements IPostQuestionDTO {
    title!: string;
    text!: string;

    constructor(data?: IPostQuestionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): PostQuestionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PostQuestionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["text"] = this.text;
        return data; 
    }
}

export interface IPostQuestionDTO {
    title: string;
    text: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}